

diff --git a/drivers/net/ethernet/intel/igb/e1000_82575.c b/drivers/net/ethernet/intel/igb/e1000_82575.c
index 1b1b4f7..c5fad76 100644
--- a/drivers/net/ethernet/intel/igb/e1000_82575.c
+++ b/drivers/net/ethernet/intel/igb/e1000_82575.c
@@ -1616,6 +1616,18 @@ static s32 igb_setup_copper_link_82575(struct e1000_hw *hw)
 		break;
 	}
 
+#if 1  //HW RD and Grace workaounrd on 2015-0710
+	if (hw->phy.type == e1000_phy_bcm54616s)
+	{
+		u16 phy_data;
+		hw->phy.ops.read_reg(hw,0x0,&phy_data);
+		phy_data |=0x8000;
+		hw->phy.ops.write_reg(hw,0x0,phy_data);
+		phy_data &=~(0x8000);
+		hw->phy.ops.write_reg(hw,0x0,phy_data);
+	}
+#endif
+
 	if (ret_val)
 		goto out;
 
@@ -1757,6 +1769,32 @@ static s32 igb_setup_serdes_link_82575(struct e1000_hw *hw)
 		hw_dbg("Configuring Forced Link:PCS_LCTL=0x%08X\n", reg);
 	}
 
+#if 1
+	if (hw->phy.type == e1000_phy_bcm54616s)
+	{
+		u16 phy_data;
+		u16 phy_temp;
+		if (hw->mac.autoneg==1)
+		{
+			/* check the link partner speed support 1G */
+			hw->phy.ops.read_reg(hw,0xa,&phy_data);
+			hw->phy.ops.read_reg(hw,0xa,&phy_temp);
+			phy_data|=phy_temp;
+
+			if ((phy_data&0x7c00)!=0)
+			{
+				/*graceliu force link for HW RD ask*/
+				reg &= ~E1000_PCS_LCTL_AN_ENABLE;     /* Disable Autoneg*/
+				reg &= ~E1000_PCS_LCTL_FORCE_LINK;    /* Disable forcelink*/
+				reg &= ~E1000_PCS_LCTL_FSD;
+				reg |= E1000_PCS_LCTL_FLV_LINK_UP |   /* Force link up */
+				    E1000_PCS_LCTL_FSV_1000 |         /* Force 1000    */
+				    E1000_PCS_LCTL_FDV_FULL ;         /* SerDes Full duplex */
+			}
+		}
+	}
+#endif
+
 	wr32(E1000_PCS_LCTL, reg);
 
 	if (!pcs_autoneg && !igb_sgmii_active_82575(hw))
diff --git a/drivers/net/ethernet/intel/igb/e1000_phy.c b/drivers/net/ethernet/intel/igb/e1000_phy.c
index 89fd6d2..f25d3b1 100644
--- a/drivers/net/ethernet/intel/igb/e1000_phy.c
+++ b/drivers/net/ethernet/intel/igb/e1000_phy.c
@@ -2054,6 +2054,9 @@ s32 igb_phy_sw_reset(struct e1000_hw *hw)
 	s32 ret_val = 0;
 	u16 phy_ctrl;
 
+	if (hw->phy.type == e1000_phy_bcm54616s)
+		return 0;
+
 	if (!(hw->phy.ops.read_reg))
 		goto out;
 
@@ -2311,6 +2314,9 @@ void igb_power_down_phy_copper(struct e1000_hw *hw)
 {
 	u16 mii_reg = 0;
 
+	if (hw->phy.type == e1000_phy_bcm54616s)
+		return;
+
 	/* The PHY will retain its settings across a power down/up cycle */
 	hw->phy.ops.read_reg(hw, PHY_CONTROL, &mii_reg);
 	mii_reg |= MII_CR_POWER_DOWN;
