Support for Accton AS4510_52T platform (ARM Cortex-A9 / Hurricane2) networking platform
Baseline files sourced from Broadcom LDK 3.4.10

diff --git a/arch/arm/boot/dts/accton_as4510_52t.dts b/arch/arm/boot/dts/accton_as4510_52t.dts
new file mode 100644
index 0000000..5ef7c60
--- /dev/null
+++ b/arch/arm/boot/dts/accton_as4510_52t.dts
@@ -0,0 +1,92 @@
+/*
+ * Accton AS4510_52T Device Tree Source
+ *
+ * Copyright 2015, Accton Technology Corporation.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/dts-v1/;
+/include/ "helix4.dtsi"
+
+/ {
+    model = "accton,as4510_52t";
+    compatible = "accton,as4510_52t";
+
+    aliases {
+        serial0 = &uart0;
+    };
+
+    memory {
+        reg = <0x61000000 0x7f000000>;
+    };
+
+    cpus {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        cpu@0 {
+            device_type = "cpu";
+            compatible = "arm,cortex-a9";
+            next-level-cache = <&L2>;
+            reg = <0x00>;
+        };
+        cpu@1 {
+            device_type = "cpu";
+            compatible = "arm,cortex-a9";
+            next-level-cache = <&L2>;
+            reg = <0x01>;
+        };
+    };
+
+    localbus@1e000000 {
+        #address-cells = <0x2>;
+        #size-cells = <0x1>;
+        compatible = "simple-bus";
+        ranges = <0x0 0x0 0x1e000000 0x02000000>;
+
+        flash@0,0 {
+            #address-cells = <0x1>;
+            #size-cells = <0x1>;
+            compatible = "cfi-flash";
+            reg = <0x0 0x0 0x00800000>;
+            bank-width = <0x1>;
+            device-width = <0x1>;
+
+            partition@0 {
+                /* uboot - 832KB*/
+                reg = <0x00000000 0x000d0000>;
+                label = "uboot";
+            };
+            partition@1 {
+                /* shmoo - 64KB*/
+                reg = <0x000d0000 0x00010000>;
+                label = "shmoo";
+            };
+            partition@2 {
+                /* uboot-env - 64KB */
+                reg = <0x000e0000 0x00010000>;
+                label = "uboot-env";
+                env_size = <0x02000>;
+            };
+            partition@3 {
+                /* onie - 7MB */
+                reg = <0x000f0000 0x00700000>;
+                label = "onie";
+            };
+            partition@4 {
+                /* hw-info - 64KB */
+                reg = <0x007f0000 0x00010000>;
+                label = "hw-info";
+            };
+            partition@5 {
+                /* diag - 24MB */
+                reg = <0x00800000 0x01800000>;
+                label = "diag";
+            };
+        };
+    };
+};
diff --git a/arch/arm/mach-iproc/board_bu.c b/arch/arm/mach-iproc/board_bu.c
index b45588d..b54e1fd 100644
--- a/arch/arm/mach-iproc/board_bu.c
+++ b/arch/arm/mach-iproc/board_bu.c
@@ -1056,6 +1056,25 @@ MACHINE_START(IPROC, "Broadcom iProc")
 	.init_machine = board_init,
 MACHINE_END
 
+static const char * hurricane2_dt_board_compat[] = {
+    "accton,as4510_52t",
+    NULL
+};
+
+DT_MACHINE_START(HURRICANE2_DT, "Broadcom Hurricane2 (Flattened Device Tree)")
+	.map_io     = board_map_io,
+	.init_early = iproc_init_early,
+	.init_irq   = iproc_init_irq,
+	.handle_irq     = gic_handle_irq,
+	.timer      = &board_timer,
+	.init_machine   = board_init,
+	.dt_compat  = hurricane2_dt_board_compat,
+MACHINE_END
+
+static const char * helix4_dt_board_compat[] = {
+    NULL
+};
+
 DT_MACHINE_START(HELIX4_DT, "Broadcom Helix4 (Flattened Device Tree)")
 	.map_io     = board_map_io,
 	.init_early = iproc_init_early,
diff --git a/arch/arm/mach-iproc/flash.c b/arch/arm/mach-iproc/flash.c
index 5eaf3ec..a715492 100644
--- a/arch/arm/mach-iproc/flash.c
+++ b/arch/arm/mach-iproc/flash.c
@@ -44,22 +44,32 @@
 #if defined(CONFIG_IPROC_QSPI) || defined(CONFIG_IPROC_QSPI_MODULE)
 static struct mtd_partition sflash_partition_map[] = {
     {
-        .name = "boot",
+        .name = "uboot",
         .offset = 0x00000000,
-        .size = 640 * 1024,
+        .size = 832 * 1024,
     },
     {
-        .name = "env",
+        .name = "shmoo",
         .offset = MTDPART_OFS_APPEND,
-        .size = 384 * 1024,
+        .size = 64 * 1024,
     },
     {
-        .name = "system",
+        .name = "uboot-env",
         .offset = MTDPART_OFS_APPEND,
-        .size = 15 * 1024 * 1024,
+        .size = 64 * 1024,
     },
     {
-        .name = "rootfs",
+        .name = "onie",
+        .offset = MTDPART_OFS_APPEND,
+        .size = 7 * 1024 * 1024,
+    },
+    {
+        .name = "hw-info",
+        .offset = MTDPART_OFS_APPEND,
+        .size = 64 * 1024,
+    },
+    {
+        .name = "diag",
         .offset = MTDPART_OFS_APPEND,
         .size = MTDPART_SIZ_FULL,
     },
@@ -69,29 +79,9 @@ static struct mtd_partition sflash_partition_map[] = {
 #if defined(CONFIG_IPROC_MTD_NAND) || defined(CONFIG_IPROC_MTD_NAND_MODULE)
 static struct mtd_partition nand_partition_map[] = {
     {
-        .name = "nboot",
+        .name = "open",
         .offset = 0x00000000,
-        .size = 2 * 1024 * 1024,
-    },
-    {
-        .name = "nenv",
-        .offset = MTDPART_OFS_APPEND,
-        .size = 4 * 1024 * 1024,
-    },
-    {
-        .name = "nsystem",
-        .offset = MTDPART_OFS_APPEND,
-        .size = 10 * 1024 * 1024,
-    },
-    {
-        .name = "nrootfs",
-        .offset = MTDPART_OFS_APPEND,
-        .size = 48 * 1024 * 1024,
-    },
-    {
-        .name = "ncustfs",
-        .offset = MTDPART_OFS_APPEND,
-        .size = MTDPART_SIZ_FULL,
+        .size = (uint64_t) 4095 * 1024 * 1024,
     },
 };
 #endif /* CONFIG_IPROC_MTD_NAND || CONFIG_IPROC_MTD_NAND_MODULE */
diff --git a/drivers/bcmdrivers/gmac/src/et/sys/etcgmac.c b/drivers/bcmdrivers/gmac/src/et/sys/etcgmac.c
index cf16543..071c991 100755
--- a/drivers/bcmdrivers/gmac/src/et/sys/etcgmac.c
+++ b/drivers/bcmdrivers/gmac/src/et/sys/etcgmac.c
@@ -428,6 +428,7 @@ chipattach(etc_info_t *etc, void *osh, void *regsva)
 	} else {
 		etc->phyaddr = bcm_atoi(var) & EPHY_MASK;
 	}
+	etc->phyaddr = 0x18;
 	printf("et%d: chipattach: phyaddr(0x%x)\n", etc->unit, etc->phyaddr);
 
 	/* nvram says no phy is present */
@@ -2273,7 +2274,7 @@ chipphyrd(ch_t *ch, uint phyaddr, uint reg)
 	uint32 addr, bank;
 	uint16 tmp16;
 
-	addr = phyaddr&0xf;
+	addr = phyaddr&0x1f;
 	bank = (phyaddr&0x1f00)>>8;
 
 	phy5221_rd_reg(ch->etc->unit, addr, bank, reg, &tmp16);
@@ -2336,7 +2337,7 @@ chipphywr(ch_t *ch, uint phyaddr, uint reg, uint16 v)
 #if defined(CONFIG_MACH_HR2)
 	uint32 addr, bank;
 
-	addr = phyaddr&0xf;
+	addr = phyaddr&0x1f;
 	bank = (phyaddr&0x1f00)>>8;
 
 	phy5221_wr_reg(ch->etc->unit, addr, bank, reg, &v);
diff --git a/drivers/bcmdrivers/gmac/src/shared/nvramstubs.c b/drivers/bcmdrivers/gmac/src/shared/nvramstubs.c
index aa8c3bd..83e7c53 100755
--- a/drivers/bcmdrivers/gmac/src/shared/nvramstubs.c
+++ b/drivers/bcmdrivers/gmac/src/shared/nvramstubs.c
@@ -100,6 +100,8 @@ static nvram_t fake_nvram[] = {
 #define CONFIG_NAND_BASE		0x1c000000
 #if (defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP))
 #define CONFIG_ENV_OFFSET		0xa0000		/* 30000-b0000 - use last 10000 for env */
+#elif defined(CONFIG_MACH_HR2)
+#define CONFIG_ENV_OFFSET		0xe0000		/* e0000-effff - use 10000 for env */
 #else
 #define CONFIG_ENV_OFFSET		0xc0000		/* 30000-b0000 - use last 10000 for env */
 #endif
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 3d6beb7..f2d9f46 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -47,6 +47,15 @@
 #define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
 #define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
 #define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
+#define	OPCODE_RDFSR		0x70	/* Read Flag Status Register */
+#define	OPCODE_RSTEN		0x66	/* Reset Enable */
+#define	OPCODE_RSTMEM		0x99	/* Reset Memory */
+
+/* 4-byte address opcodes - used on Spansion and some Macronix flashes. */
+#define	OPCODE_NORM_READ_4B	0x13	/* Read data bytes (low frequency) */
+#define	OPCODE_FAST_READ_4B	0x0c	/* Read data bytes (high frequency) */
+#define	OPCODE_PP_4B		0x12	/* Page program (up to 256 bytes) */
+#define	OPCODE_SE_4B		0xdc	/* Sector erase (usually 64KiB) */
 
 /* Used for SST flashes only. */
 #define	OPCODE_BP		0x02	/* Byte program */
@@ -69,15 +78,20 @@
 #define	SR_BP2			0x10	/* Block protect 2 */
 #define	SR_SRWD			0x80	/* SR write protect */
 
+/* Flag Status Register bits. */
+#define	FSR_RDY			0x80	/* Ready/Busy program erase controller */
+
 /* Define max times to check status register before we give up. */
 #define	MAX_READY_WAIT_JIFFIES	(40 * HZ)	/* M25P16 specs 40s max chip erase */
 #define	MAX_CMD_SIZE		6
 
 #ifdef CONFIG_M25PXX_USE_FAST_READ
 #define OPCODE_READ 	OPCODE_FAST_READ
+#define OPCODE_READ_4B 	OPCODE_FAST_READ_4B
 #define FAST_READ_DUMMY_BYTE 1
 #else
 #define OPCODE_READ 	OPCODE_NORM_READ
+#define OPCODE_READ_4B 	OPCODE_NORM_READ_4B
 #define FAST_READ_DUMMY_BYTE 0
 #endif
 
@@ -91,7 +105,10 @@ struct m25p {
 	struct mtd_info		mtd;
 	u16			page_size;
 	u16			addr_width;
+	bool			check_fsr;
 	u8			erase_opcode;
+	u8			read_opcode;
+	u8			program_opcode;
 	u8			*command;
 };
 
@@ -107,6 +124,28 @@ static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)
  */
 
 /*
+ * Read the Flag Status Register (required for some Micron chips).
+ * Return the Flag Status Register value.
+ * Returns negative if error occurred.
+ */
+static int read_fsr(struct m25p *flash)
+{
+	ssize_t retval;
+	u8 code = OPCODE_RDFSR;
+	u8 val;
+
+	retval = spi_write_then_read(flash->spi, &code, 1, &val, 1);
+
+	if (retval < 0) {
+		dev_err(&flash->spi->dev, "error %d reading FSR\n",
+				(int) retval);
+		return retval;
+	}
+
+	return val;
+}
+
+/*
  * Read the status register, returning its value in the location
  * Return the status register value.
  * Returns negative if error occurred.
@@ -166,10 +205,18 @@ static inline int write_disable(struct m25p *flash)
  */
 static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
 {
+	int status;
+
 	switch (JEDEC_MFR(jedec_id)) {
 	case CFI_MFR_MACRONIX:
 		flash->command[0] = enable ? OPCODE_EN4B : OPCODE_EX4B;
 		return spi_write(flash->spi, flash->command, 1);
+	case CFI_MFR_ST: /* Micron, actually */
+		flash->command[0] = enable ? OPCODE_EN4B : OPCODE_EX4B;
+		write_enable(flash);
+		status = spi_write(flash->spi, flash->command, 1);
+		write_disable(flash);
+		return status;
 	default:
 		/* Spansion style */
 		flash->command[0] = OPCODE_BRWR;
@@ -185,15 +232,21 @@ static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
 static int wait_till_ready(struct m25p *flash)
 {
 	unsigned long deadline;
-	int sr;
+	int sr, fsr;
 
 	deadline = jiffies + MAX_READY_WAIT_JIFFIES;
 
 	do {
 		if ((sr = read_sr(flash)) < 0)
 			break;
-		else if (!(sr & SR_WIP))
+		else if (!(sr & SR_WIP)) {
+			if (flash->check_fsr) {
+				fsr = read_fsr(flash);
+				if (!(fsr & FSR_RDY))
+					return 1;
+			}
 			return 0;
+		}
 
 		cond_resched();
 
@@ -389,7 +442,7 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 	 */
 
 	/* Set up the write data buffer. */
-	flash->command[0] = OPCODE_READ;
+	flash->command[0] = flash->read_opcode;
 	m25p_addr2cmd(flash, from, flash->command);
 
 	spi_sync(flash->spi, &m);
@@ -447,7 +500,7 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 	write_enable(flash);
 
 	/* Set up the opcode in the write buffer. */
-	flash->command[0] = OPCODE_PP;
+	flash->command[0] = flash->program_opcode;
 	m25p_addr2cmd(flash, to, flash->command);
 
 	page_offset = to & (flash->page_size - 1);
@@ -625,6 +678,7 @@ struct flash_info {
 	u16		flags;
 #define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
 #define	M25P_NO_ERASE	0x02		/* No erase command needed */
+#define	E_FSR		0x08		/* Flag SR exists for flash */
 };
 
 #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
@@ -928,20 +982,34 @@ static int __devinit m25p_probe(struct spi_device *spi)
 	if (info->flags & M25P_NO_ERASE)
 		flash->mtd.flags |= MTD_NO_ERASE;
 
+	if (info->flags & E_FSR)
+		flash->check_fsr = 1;
+
 	ppdata.of_node = spi->dev.of_node;
 	flash->mtd.dev.parent = &spi->dev;
 	flash->page_size = info->page_size;
 	flash->mtd.writebufsize = flash->page_size;
 
+	/* Default commands */
+	flash->read_opcode = OPCODE_READ;
+	flash->program_opcode = OPCODE_PP;
+
 	if (info->addr_width)
 		flash->addr_width = info->addr_width;
-	else {
+	else if (flash->mtd.size > 0x1000000) {
 		/* enable 4-byte addressing if the device exceeds 16MiB */
-		if (flash->mtd.size > 0x1000000) {
-			flash->addr_width = 4;
-			set_4byte(flash, info->jedec_id, 1);
+		flash->addr_width = 4;
+		if (JEDEC_MFR(info->jedec_id) == CFI_MFR_AMD) {
+			/* Dedicated 4-byte command set */
+			flash->read_opcode = OPCODE_READ_4B;
+			flash->program_opcode = OPCODE_PP_4B;
+			/* No small sector erase for 4-byte command set */
+			flash->erase_opcode = OPCODE_SE_4B;
+			flash->mtd.erasesize = info->sector_size;
 		} else
-			flash->addr_width = 3;
+			set_4byte(flash, info->jedec_id, 1);
+	} else {
+		flash->addr_width = 3;
 	}
 
 	dev_info(&spi->dev, "%s (%lld Kbytes)\n", id->name,
@@ -984,6 +1052,32 @@ static int __devexit m25p_remove(struct spi_device *spi)
 	return 0;
 }
 
+static void m25p_shutdown(struct spi_device *spi)
+{
+	struct m25p *flash		= dev_get_drvdata(&spi->dev);
+	const struct spi_device_id *id	= spi_get_device_id(spi);
+	struct flash_info *info		= (void *)id->driver_data;
+	ssize_t retval;
+	u8 code;
+
+	code = OPCODE_RSTEN;
+	retval = spi_write_then_read(spi, &code, 1, NULL, 0);
+
+	if (retval < 0) {
+		dev_err(&spi->dev, "error %d Reset Enable\n",
+				(int) retval);
+	}
+
+	code = OPCODE_RSTMEM;
+	retval = spi_write_then_read(spi, &code, 1, NULL, 0);
+
+	if (retval < 0) {
+		dev_err(&spi->dev, "error %d Reset Memory\n",
+				(int) retval);
+	}
+
+	while (wait_till_ready(flash));
+}
 
 static struct spi_driver m25p80_driver = {
 	.driver = {
@@ -994,6 +1088,7 @@ static struct spi_driver m25p80_driver = {
 	.id_table	= m25p_ids,
 	.probe	= m25p_probe,
 	.remove	= __devexit_p(m25p_remove),
+	.shutdown = m25p_shutdown,
 
 	/* REVISIT: many of these chips have deep power-down modes, which
 	 * should clearly be entered on suspend() to minimize power use.
